{"version":3,"file":"js-joda-timezone.js","sources":["../src/MomentZoneRules.js","../src/unpack.js","../src/MomentZoneRulesProvider.js","../src/system-default-zone.js","../src/plug.js","../src/auto-plug.js","../src/js-joda-timezone.js"],"sourcesContent":["/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {\n    LocalDateTime, Instant, ZoneOffset, ZoneOffsetTransition, ZoneRules\n} from '@js-joda/core';\n\nexport class MomentZoneRules extends ZoneRules{\n    constructor(tzdbInfo){\n        super();\n        this._tzdbInfo = tzdbInfo;\n        this._ldtUntils = new LDTUntils(this._tzdbInfo.untils, this._tzdbInfo.offsets);\n    }\n    /**\n     * Checks of the zone rules are fixed, such that the offset never varies.\n     *\n     * @return {boolean} true if the time-zone is fixed and the offset never changes\n     */\n    isFixedOffset(){\n        return this._tzdbInfo.offsets.length === 1;\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets the offset applicable at the specified instant in these rules.\n     * <p>\n     * The mapping from an instant to an offset is simple, there is only\n     * one valid offset for each instant.\n     * This method returns that offset.\n     *\n     * @param {Instant} instant - the instant to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    offsetOfInstant(instant){\n        const epochMilli = instant.toEpochMilli();\n        return this.offsetOfEpochMilli(epochMilli);\n    }\n\n    /**\n     * Gets the offset applicable at the specified epochMilli in these rules.\n     *\n     * The method is for javascript performance optimisation.\n     *\n     * @param {number} epochMilli - the epoch millisecond to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    offsetOfEpochMilli(epochMilli){\n        const index  = binarySearch(this._tzdbInfo.untils, epochMilli);\n        return ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(index));\n    }\n\n\n    /**\n     * Gets a suitable offset for the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns the single offset in the Normal case, and in the Gap or Overlap\n     * case it returns the offset before the transition.\n     * <p>\n     * Since, in the case of Gap and Overlap, the offset returned is a \"best\" value, rather\n     * than the \"correct\" value, it should be treated with care. Applications that care\n     * about the correct offset should use a combination of this method,\n     * {@link #getValidOffsets(LocalDateTime)} and {@link #getTransition(LocalDateTime)}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the best available offset for the local date-time, not null\n     */\n    offsetOfLocalDateTime(localDateTime){\n        const info = this._offsetInfo(localDateTime);\n        if (info instanceof ZoneOffsetTransition) {\n            return info.offsetBefore();\n        }\n        return info;\n    }\n\n    _offsetInfo(localDateTime) {\n        const index  = ldtBinarySearch(this._ldtUntils, localDateTime);\n        const offsetIndex = index >> 1;\n\n        if (index % 2 === 1){\n            const ldtBefore = this._ldtUntils.get(Math.max(index-1, 0));\n            const ldtAfter = this._ldtUntils.get(Math.min(index, this._ldtUntils.size-1));\n            const offsetBefore = ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(offsetIndex));\n            const offsetAfter = ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(Math.min(offsetIndex+1, this._tzdbInfo.offsets.length-1)));\n            // console.log(offsetBefore.toString(), offsetAfter.toString());\n            if (offsetBefore.compareTo(offsetAfter) > 0) {\n                // gap\n                // console.log('gap', ldtBefore.toString(), localDateTime.toString(), ldtAfter.toString());\n                return ZoneOffsetTransition.of(ldtBefore, offsetBefore, offsetAfter);\n            } else {\n                // overlap\n                // console.log('overlap', ldtBefore.toString(), localDateTime.toString(), ldtAfter.toString());\n                return ZoneOffsetTransition.of(ldtAfter, offsetBefore, offsetAfter);\n            }\n        }\n        return ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(offsetIndex));\n    }\n\n    _offsetByIndexInSeconds(index){\n        return -offsetInSeconds(this._tzdbInfo.offsets[index]);\n    }\n\n    /**\n     * Gets the offset applicable at the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns that list of valid offsets, which is a list of size 0, 1 or 2.\n     * In the case where there are two offsets, the earlier offset is returned at index 0\n     * and the later offset at index 1.\n     * <p>\n     * There are various ways to handle the conversion from a {@code LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  List<ZoneOffset> validOffsets = rules.getOffset(localDT);\n     *  if (validOffsets.size() == 1) {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = validOffsets.get(0);\n     *  } else {\n     *    // Gap or Overlap: determine what to do from transition (which will be non-null)\n     *    ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  }\n     * </pre>\n     * <p>\n     * In theory, it is possible for there to be more than two valid offsets.\n     * This would happen if clocks to be put back more than once in quick succession.\n     * This has never happened in the history of time-zones and thus has no special handling.\n     * However, if it were to happen, then the list would return more than 2 entries.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query for valid offsets, not null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition | ZoneOffset[]} the list of valid offsets, may be immutable, not null\n     */\n    validOffsets(localDateTime){\n        const info = this._offsetInfo(localDateTime);\n        if (info instanceof ZoneOffsetTransition) {\n            return info.validOffsets();\n        }\n        return [info];\n    }\n\n    /**\n     * Gets the offset transition applicable at the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * A transition is used to model the cases of a Gap or Overlap.\n     * The Normal case will return null.\n     * <p>\n     * There are various ways to handle the conversion from a {@code LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  if (trans != null) {\n     *    // Gap or Overlap: determine what to do from transition\n     *  } else {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = rule.getOffset(localDT);\n     *  }\n     * </pre>\n     *\n     * @param {LocalDateTime} localDateTime  the local date-time to query for offset transition, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the offset transition, null if the local date-time is not in transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    transition(localDateTime){\n        const info = this._offsetInfo(localDateTime);\n        if (info instanceof ZoneOffsetTransition) {\n            return info;\n        }\n        return null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the standard offset for the specified instant in this zone.\n     * <p>\n     * This provides access to historic information on how the standard offset\n     * has changed over time.\n     * The standard offset is the offset before any daylight saving time is applied.\n     * This is typically the offset applicable during winter.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    standardOffset(instant){\n        notSupported('ZoneRules.standardOffset');\n    }\n\n    /**\n     * Gets the amount of daylight savings in use for the specified instant in this zone.\n     * <p>\n     * This provides access to historic information on how the amount of daylight\n     * savings has changed over time.\n     * This is the difference between the standard offset and the actual offset.\n     * Typically the amount is zero during winter and one hour during summer.\n     * Time-zones are second-based, so the nanosecond part of the duration will be zero.\n     *\n     * @param {Instant} instant - the instant to find the daylight savings for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {Duration} the difference between the standard and actual offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    daylightSavings(instant){\n        notSupported('ZoneRules.daylightSavings');\n    }\n\n    /**\n     * Checks if the specified instant is in daylight savings.\n     * <p>\n     * This checks if the standard and actual offsets are the same at the specified instant.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {boolean} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    isDaylightSavings(instant) {\n        notSupported('ZoneRules.isDaylightSavings');\n    }\n\n    /**\n     * Checks if the offset date-time is valid for these rules.\n     * <p>\n     * To be valid, the local date-time must not be in a gap and the offset\n     * must match the valid offsets.\n     *\n     * @param {LocalDateTime} localDateTime - the date-time to check, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @param {ZoneOffset} offset - the offset to check, null returns false\n     * @return {boolean} true if the offset date-time is valid for these rules\n     */\n    isValidOffset(localDateTime, offset){\n        return this.validOffsets(localDateTime).some( o => o.equals(offset));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the next transition after the specified instant.\n     * <p>\n     * This returns details of the next transition after the specified instant.\n     * For example, if the instant represents a point where \"Summer\" daylight savings time\n     * applies, then the method will return the transition to the next \"Winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the next transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the next transition after the specified instant, null if this is after the last transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    nextTransition(instant){\n        notSupported('ZoneRules.nextTransition');\n    }\n\n    /**\n     * Gets the previous transition before the specified instant.\n     * <p>\n     * This returns details of the previous transition after the specified instant.\n     * For example, if the instant represents a point where \"summer\" daylight saving time\n     * applies, then the method will return the transition from the previous \"winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the previous transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the previous transition after the specified instant, null if this is before the first transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    previousTransition(instant){\n        notSupported('ZoneRules.previousTransition');\n    }\n\n    /**\n     * Gets the complete list of fully defined transitions.\n     * <p>\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link #getTransitionRules()}. This method returns those transitions that have\n     * been fully defined. These are typically historical, but may be in the future.\n     * <p>\n     * The list will be empty for fixed offset rules and for any time-zone where there has\n     * only ever been a single offset. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransition[]} an immutable list of fully defined transitions, not null\n     */\n    transitions(){\n        notSupported('ZoneRules.transitions');\n    }\n\n    /**\n     * Gets the list of transition rules for years beyond those defined in the transition list.\n     * <p>\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link #getTransitions()}. This method returns instances of {@link ZoneOffsetTransitionRule}\n     * that define an algorithm for when transitions will occur.\n     * <p>\n     * For any given {@code ZoneRules}, this list contains the transition rules for years\n     * beyond those years that have been fully defined. These rules typically refer to future\n     * daylight saving time rule changes.\n     * <p>\n     * If the zone defines daylight savings into the future, then the list will normally\n     * be of size two and hold information about entering and exiting daylight savings.\n     * If the zone does not have daylight savings, or information about future changes\n     * is uncertain, then the list will be empty.\n     * <p>\n     * The list will be empty for fixed offset rules and for any time-zone where there is no\n     * daylight saving time. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransitionRule[]} an immutable list of transition rules, not null\n     */\n    transitionRules(){\n        notSupported('ZoneRules.transitionRules');\n    }\n\n    /**\n     *\n     * @param other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof MomentZoneRules) {\n            return this._tzdbInfo === other._tzdbInfo;\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return this._tzdbInfo.name;\n    }\n}\n\nclass LDTUntils {\n    constructor(_tzdbUntils, tzdbOffsets) {\n        this._tzdbUntils = _tzdbUntils;\n        this._tzdbOffsets = tzdbOffsets;\n        this._ldtUntils = [];\n        this.size = this._tzdbUntils.length * 2;\n    }\n\n\n    _generateTupple(index) {\n        const epochMillis = this._tzdbUntils[index];\n        if (epochMillis === Infinity) {\n            return [LocalDateTime.MAX, LocalDateTime.MAX];\n        }\n        const instant = Instant.ofEpochMilli(epochMillis);\n\n        const offset1 = offsetInSeconds(this._tzdbOffsets[index]);\n        const zone1 = ZoneOffset.ofTotalSeconds(-offset1);\n        const ldt1 = LocalDateTime.ofInstant(instant, zone1);\n\n        const nextIndex = Math.min(index + 1, this._tzdbOffsets.length - 1);\n        const offset2 = offsetInSeconds(this._tzdbOffsets[nextIndex]);\n        const zone2 = ZoneOffset.ofTotalSeconds(-offset2);\n        const ldt2 = LocalDateTime.ofInstant(instant, zone2);\n\n        if(offset1 > offset2) {\n            return [ldt1, ldt2];\n        } else {\n            return [ldt2, ldt1];\n        }\n    }\n\n    _getTupple(index){\n        if (this._ldtUntils[index] == null) {\n            this._ldtUntils[index] = this._generateTupple(index);\n        }\n        return this._ldtUntils[index];\n    }\n\n    get(index) {\n        const ldtTupple = this._getTupple(index >> 1);\n        return ldtTupple[index % 2];\n    }\n}\n\n// modified bin-search, to always find existing indices for non-empty arrays\n// value in array at index is larger than input value (or last index of array)\nfunction ldtBinarySearch(array, value) {\n    let hi = array.size - 1, lo = -1, mid;\n    while (hi - lo > 1) {\n        if (!value.isBefore(array.get(mid = hi + lo >> 1))) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return hi;\n}\n\nfunction offsetInSeconds(tzdbOffset){\n    return roundDown(+tzdbOffset*60);\n}\n\nfunction roundDown(r){\n    if (r < 0) {\n        return Math.ceil(r);\n    } else {\n        return Math.floor(r);\n    }\n}\n\n// modified bin-search, to always find existing indices for non-empty arrays\n// value in array at index is larger than input value (or last index of array)\nfunction binarySearch(array, value) {\n    let hi = array.length - 1, lo = -1, mid;\n    while (hi - lo > 1) {\n        if (array[mid = hi + lo >> 1] <= value) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return hi;\n}\n\nfunction notSupported(msg){\n    throw new Error(`not supported: ${msg}`);\n}\n","/* eslint-disable no-var */\n\n//! moment-timezone.js\n//! version : 0.5.2\n//! author : Tim Wood\n//! license : MIT\n//! github.com/moment/moment-timezone\n\n/************************************\n Unpacking\n ************************************/\n\n/**\n * @private\n *\n * @param charCode\n * @returns {number}\n */\nfunction charCodeToInt(charCode) {\n    if (charCode > 96) {\n        return charCode - 87;\n    } else if (charCode > 64) {\n        return charCode - 29;\n    }\n    return charCode - 48;\n}\n\nfunction unpackBase60(string) {\n    var i = 0,\n        parts = string.split('.'),\n        whole = parts[0],\n        fractional = parts[1] || '',\n        multiplier = 1,\n        num,\n        out = 0,\n        sign = 1;\n\n    // handle negative numbers\n    if (string.charCodeAt(0) === 45) {\n        i = 1;\n        sign = -1;\n    }\n\n    // handle digits before the decimal\n    for (i; i < whole.length; i++) {\n        num = charCodeToInt(whole.charCodeAt(i));\n        out = 60 * out + num;\n    }\n\n    // handle digits after the decimal\n    for (i = 0; i < fractional.length; i++) {\n        multiplier = multiplier / 60;\n        num = charCodeToInt(fractional.charCodeAt(i));\n        out += num * multiplier;\n    }\n\n    return out * sign;\n}\n\nfunction arrayToInt (array) {\n    for (var i = 0; i < array.length; i++) {\n        array[i] = unpackBase60(array[i]);\n    }\n}\n\nfunction intToUntil (array, length) {\n    for (var i = 0; i < length; i++) {\n        array[i] = Math.round((array[i - 1] || 0) + (array[i] * 60000)); // minutes to milliseconds\n    }\n\n    array[length - 1] = Infinity;\n}\n\nfunction mapIndices (source, indices) {\n    var out = [], i;\n\n    for (i = 0; i < indices.length; i++) {\n        out[i] = source[indices[i]];\n    }\n\n    return out;\n}\n\n/**\n * @private\n *\n * @param string\n * @returns {{offsets: *[], abbrs: *[], name, untils: *, population: number}}\n */\nexport function unpack (string) {\n    var data = string.split('|'),\n        offsets = data[2].split(' '),\n        indices = data[3].split(''),\n        untils  = data[4].split(' ');\n\n    arrayToInt(offsets);\n    arrayToInt(indices);\n    arrayToInt(untils);\n\n    intToUntil(untils, indices.length);\n\n    return {\n        name       : data[0],\n        abbrs      : mapIndices(data[1].split(' '), indices),\n        offsets    : mapIndices(offsets, indices),\n        untils     : untils,\n        population : data[5] | 0\n    };\n}\n\n","/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {\n    DateTimeException,\n    ZoneRulesProvider,\n} from '@js-joda/core';\n\nimport { MomentZoneRules } from './MomentZoneRules';\n\nimport { unpack } from './unpack';\n\nlet TZDB_DATA;\nlet TZDB_VERSION;\nconst AVAILABLE_ZONE_IDS = [];\n\nconst zones = {};\nconst links = {};\n\nexport class MomentZoneRulesProvider extends ZoneRulesProvider {\n    /**\n     * Gets the rules for the zone ID.\n     * <p>\n     * This returns the latest available rules for the zone ID.\n     * <p>\n     * This method relies on time-zone data provider files that are configured.\n     *\n     * @param {string} zoneId\n     * @return {ZoneRules}\n     */\n    static getRules(zoneId){\n        const tzdbZoneInfo = zones[links[zoneId]];\n        if(tzdbZoneInfo == null){\n            throw new DateTimeException(`Unknown time-zone ID: ${zoneId}`);\n        }\n        return new MomentZoneRules(tzdbZoneInfo);\n    }\n\n\n    /**\n     * Gets the set of available zone IDs.\n     * <p>\n     * These zone IDs are loaded and available for use by {@code ZoneId}.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds(){\n        return AVAILABLE_ZONE_IDS;\n    }\n\n    /**\n     *\n     * @return {string} the tzdb version.\n     */\n    static getVersion() {\n        return TZDB_VERSION;\n    }\n\n    /**\n     * Provides the packed tzdb data,\n     * the data has the same format as provided from moment-timezone.\n     *\n     * @return {object} the packed tzdb data.\n     */\n    static getTzdbData(){\n        return TZDB_DATA;\n    }\n\n    /**\n     * Sets the packed tzdb data.\n     * Accepts tzdb data in the same format as provided from moment-timezone.\n     *\n     * @param packedJson\n     */\n    static loadTzdbData(packedJson){\n        TZDB_DATA = packedJson;\n        TZDB_VERSION = packedJson.version;\n\n        for (const packedZoneInfo of packedJson.zones) {\n            const tzdbZoneInfo = unpack(packedZoneInfo);\n            AVAILABLE_ZONE_IDS.push(tzdbZoneInfo.name);\n            zones[tzdbZoneInfo.name] = tzdbZoneInfo;\n            links[tzdbZoneInfo.name] = tzdbZoneInfo.name;\n        }\n\n        for (const packedLink of packedJson.links) {\n            const link = packedLink.split('|');\n            AVAILABLE_ZONE_IDS.push(link[1]);\n            links[link[1]] = link[0];\n        }\n    }\n}\n","/**\n * @private\n *\n * @param ZoneId\n * @returns {null|*}\n */\nfunction getResolvedZoneId(ZoneId) {\n    try {\n        const resolvedTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        return ZoneId.of(resolvedTimeZone);\n    } catch (err) {\n        // ignore\n    }\n    return null;\n}\n\n/**\n * @private\n *\n * @param ZoneId\n */\nexport default function extendSystemDefaultZoneId(ZoneId) {\n    const resolvedZoneId = getResolvedZoneId(ZoneId);\n\n    if (resolvedZoneId == null) {\n        return;\n    }\n\n    ZoneId.systemDefault = function () {\n        return resolvedZoneId;\n    };\n}\n","/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { MomentZoneRulesProvider } from './MomentZoneRulesProvider';\nimport extendSystemDefaultZoneId from './system-default-zone';\n\n/**\n * @private\n */\nexport default function (jsJoda) {\n    jsJoda.ZoneRulesProvider.getRules = MomentZoneRulesProvider.getRules;\n    jsJoda.ZoneRulesProvider.getAvailableZoneIds = MomentZoneRulesProvider.getAvailableZoneIds;\n    jsJoda.ZoneRulesProvider.getTzdbData = MomentZoneRulesProvider.getTzdbData;\n    jsJoda.ZoneRulesProvider.loadTzdbData = MomentZoneRulesProvider.loadTzdbData;\n\n    extendSystemDefaultZoneId(jsJoda.ZoneId);\n    return jsJoda;\n}\n","/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { use } from '@js-joda/core';\n\nimport plug from './plug';\n\n/**\n * @private\n */\nexport default function autoPlug() {\n    use(plug);\n}\n\n","/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport latest from './tzdbData';\n\nimport { MomentZoneRulesProvider } from './MomentZoneRulesProvider';\nimport autoPlug from './auto-plug';\n\nMomentZoneRulesProvider.loadTzdbData(latest);\n\nautoPlug();\n"],"names":["MomentZoneRules","_ZoneRules","_inheritsLoose","tzdbInfo","_this","call","_tzdbInfo","_ldtUntils","LDTUntils","untils","offsets","_proto","prototype","isFixedOffset","length","offsetOfInstant","instant","epochMilli","toEpochMilli","offsetOfEpochMilli","index","binarySearch","ZoneOffset","ofTotalSeconds","_offsetByIndexInSeconds","offsetOfLocalDateTime","localDateTime","info","_offsetInfo","ZoneOffsetTransition","offsetBefore","ldtBinarySearch","offsetIndex","ldtBefore","get","Math","max","ldtAfter","min","size","offsetAfter","compareTo","of","offsetInSeconds","validOffsets","transition","standardOffset","notSupported","daylightSavings","isDaylightSavings","isValidOffset","offset","some","o","equals","nextTransition","previousTransition","transitions","transitionRules","other","toString","name","ZoneRules","_tzdbUntils","tzdbOffsets","_tzdbOffsets","_proto2","_generateTupple","epochMillis","Infinity","LocalDateTime","MAX","Instant","ofEpochMilli","offset1","zone1","ldt1","ofInstant","nextIndex","offset2","zone2","ldt2","_getTupple","ldtTupple","array","value","hi","lo","mid","isBefore","tzdbOffset","roundDown","r","ceil","floor","msg","Error","charCodeToInt","charCode","unpackBase60","string","i","parts","split","whole","fractional","multiplier","num","out","sign","charCodeAt","arrayToInt","intToUntil","round","mapIndices","source","indices","unpack","data","abbrs","population","TZDB_DATA","TZDB_VERSION","AVAILABLE_ZONE_IDS","zones","links","MomentZoneRulesProvider","_ZoneRulesProvider","apply","arguments","getRules","zoneId","tzdbZoneInfo","DateTimeException","getAvailableZoneIds","getVersion","getTzdbData","loadTzdbData","packedJson","version","_iterator","_createForOfIteratorHelperLoose","_step","done","packedZoneInfo","push","_iterator2","_step2","packedLink","link","ZoneRulesProvider","getResolvedZoneId","ZoneId","resolvedTimeZone","Intl","DateTimeFormat","resolvedOptions","timeZone","err","extendSystemDefaultZoneId","resolvedZoneId","systemDefault","jsJoda","autoPlug","use","plug","latest"],"mappings":"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"}